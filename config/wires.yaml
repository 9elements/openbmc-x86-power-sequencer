# Inputs are monitored using interrupts and trigger the internal state machine.
inputs:
  - FM_SLPS3_N:
    type: "gpio"
    name: "FM_SLPS3_N"
    active_low: true
    description: "Indicates that the PCH is in ACPI S3."
  - FM_SLPS4_N:
    type: "gpio"
    name: "FM_SLPS4_N"
    active_low: true
    description: "Indicates that the PCH is in ACPI S4 or S5."
  - PWRGD_CPUPWRGD:
    type: "gpio"
    name: "PROC_PWRGD"
    description: "Informs the CPU that power is stable and clocks are running."
  - RST_PLTRST_N:
    name: "PLTRST_N"
    type: "gpio"
    active_low: true
    description: "Global platform reset signal. Not all PCIe devices might be affected by this signal."
  - RST_RTCRST_N:
    name: "RTCRST_N"
    type: "gpio"
    active_low: true
    description: "RTC well reset. With RTC battery installed should never be asserted. Without RTC battery asserted when in G3."


# List of outputs controlled by the program. An output can be a GPIO or
# a voltage regulator
outputs:
  - H_LVT1_THERMTRIP_N:
    name: "THRMTRIP_N"
    type: "gpio"
    active_low: true
    description: "Signal from CPU indicating an overheat condition. PCH will got to S5 without following normal transition flow."
    comment: "PCH will immediately drive CPUPWRGD low and assert PLTRST_N, SLP_S3_N, SLP_S4_N, SLP_S5_N."
  - PWRGD_SYS_PWROK:
    type: "gpio"
    name: "SYS_PWROK"
    description: "Generic power good. CPU is good to come out of reset."
    comment: "!SLP_S3, PCH_PWROK, CPU rails enabled && CPU rails OK"
  - PWRGD_PCH_PWROK:
    type: "gpio"
    name: "PCH_PWROK"
    description: "PCH core power good for at least 10msec."
    comment: "!FM_SLPS3_N && PCH_PWR_EN && !FAULT"
  - PWRGD_PCH_DPWROK:
    type: "gpio"
    name: "DSW_PWROK"
    description: "PCH core power good for at least 10msec. Min 1 usec after RTCRST_N"
  - RST_PCH_RSMRST_R_N:
    type: "gpio"
    name: "RSMRST_N"
    description: "All PCH primary power rails are stable for 10 msec. Either assert after SLP_SUS_N or 100msec after DSW_PWROK assertion."

# Wires are used to connect Units
wires:
  - "P1V05_PCH_AUX_ENABLE"
  - "PVNN_PCH_AUX_ENABLE"
  - "P1V8_PCH_AUX_ENABLE"
  - "P5V_AUX_ENABLE"
  - "P3V3_AUX_ENABLE"
  - "PVDDQ_ABC_DELAY"
  - "DDR_POWER"

# Contains a list of units. Every unit contains logic (similar to a LUT in a CPLD).
# Units contain AND gates and OR gates. The order of AND and OR gates is controled
# by 'and_then_or' flag. Every input can be inverted.
# If the inputs need to be stable and logical '1' for a specific amount of time specify
# 'input_stable_usec'. If the input is not stable or logical '0' the result is '0'.
# If the first gate is AND and 'invert_first_gate' is set, it acts like a NAND gate.
# If the first gate is OR and 'invert_first_gate' is set, it acts like a NOR gate.
# Specify 'delay_usec' to delay the input signal by usec.

power_sequencer:
# VCCPDSW_3P3 is connected to P3V3_PCH, which is controled by AUX_SSB and produced by P3V3_AUX
  - DSW_PWRGD_Unit:
    - in:
      and:
        - name: "RTCRST_N"
        - name: "P3V3_AUX_Enabled"
        - name: "P3V3_AUX_Fault"
          invert: true
        - name: "AUX_SSB_Enabled"
          input_stable_usec: 10000
        - name: "AUX_SSB_Fault"
          invert: true
    - out:
      name: "PWRGD_PCH_DPWROK"

  - P3V3_AUX_Unit:
    - in:
      and:
        - name: "ACPI_STATE_G3"
          invert: true
        - name: "RTCRST_N"
          input_stable_usec: 9000
    - out:
      name: "P3V3_AUX_ENABLE"
  
  - P3V3_AUX_Delay_Unit:
    - in:
      and:
        - name: "P3V3_AUX_ENABLE"
      delay_usec: 1000
    - out:
      name: "P3V3_AUX_On"

  - P5V_AUX_Unit:
    - in:
      and:
        - name: "ACPI_STATE_G3"
          invert: true
        - name: "RTCRST_N"
          input_stable_usec: 9000
        - name: "P3V3_AUX_Enabled"
          input_stable_usec: 100
    - out:
      name: "P5V_AUX_ENABLE"

  - P5V_AUX_Delay_Unit:
    - in:
      and:
        - name: "P5V_AUX_ENABLE"
      delay_usec: 1000
    - out:
      name: "P5V_AUX_On"

  - P1V8_PCH_AUX_Unit:
    - in:
      and:
        - name: "ACPI_STATE_G3"
          invert: true
        - name: "P3V3_AUX_Enabled"
          input_stable_usec: 100 # min 2 usec
        - name: "P3V3_AUX_Fault"
          invert: true
    - out:
      name: "P1V8_PCH_AUX_ENABLE"

  - P1V8_PCH_AUX_Delay_Unit:
    - in:
      and:
        - name: "P1V8_PCH_AUX_ENABLE"
      delay_usec: 1000
    - out:
      name: "P1V8_PCH_AUX_On"

  - PVNN_PCH_AUX_Unit:
    - in:
      and:
        - name: "ACPI_STATE_G3"
          invert: true
        - name: "P1V8_PCH_AUX_Enabled"
          input_stable_usec: 100 # min 2 usec
        - name: "P1V8_PCH_AUX_Fault"
          invert: true
    - out:
      name: "PVNN_PCH_AUX_ENABLE"

  - PVNN_PCH_AUX_Delay_Unit:
    - in:
      and:
        - name: "PVNN_PCH_AUX_ENABLE"
      delay_usec: 1000
    - out:
      name: "PVNN_PCH_AUX_On"

  - P1V05_PCH_AUX_Unit:
    - in:
      and:
        - name: "ACPI_STATE_G3"
          invert: true
        - name: "PVNN_PCH_AUX_Enabled"
          input_stable_usec: 100 # min 2 usec
        - name: "P1V8_PCH_AUX_Fault"
          invert: true
        - name: "PVNN_PCH_AUX_Fault"
          invert: true
    - out:
      active_low: false
      name: "P1V05_PCH_AUX_ENABLE"

  - P1V05_PCH_AUX_Delay_Unit:
    - in:
      and:
        - name: "P1V05_PCH_AUX_ENABLE"
      delay_usec: 1000
    - out:
      name: "P1V05_PCH_AUX_On"

  - RSMRST_Unit: # When high then AUX power is on and system is in S5, else G3
   - in:
      and:
        - name: "P1V05_PCH_AUX_Enabled"
          input_stable_usec: 10000 # min 10 msec
        - name: "P1V8_PCH_AUX_Enabled"
          input_stable_usec: 10000 # min 10 msec
        - name: "PVNN_PCH_AUX_Enabled"
          input_stable_usec: 10000 # min 10 msec
        - name: "P1V05_PCH_AUX_Enabled"
          input_stable_usec: 10000 # min 10 msec
        - name: "P3V3_AUX_Enabled"
          input_stable_usec: 10000 # min 10 msec
        - name: "P1V8_PCH_AUX_Fault"
          invert: true
        - name: "PVNN_PCH_AUX_Fault"
          invert: true
        - name: "P1V05_PCH_AUX_Fault"
          invert: true
        - name: "P3V3_AUX_Fault"
          invert: true
        - name: "P1V05_PCH_AUX_ENABLE"
        - name: "PVNN_PCH_AUX_ENABLE"
        - name: "P1V8_PCH_AUX_ENABLE"
        - name: "P5V_AUX_ENABLE"
        - name: "P3V3_AUX_ENABLE"
      or: {}
      and_then_or: false
      invert_first_gate: false
      input_stable_usec: 0
    - out:
      active_low: false
      name: "RST_PCH_RSMRST_R_N"

  - P5V0_Unit:
    - in:
      and:
        - name: "P5V_AUX_Enabled"
        - name: "P5V_AUX_Fault"
          invert: false
        - name: "P3V3_AUX_Fault"
          invert: false
        - name: "FM_SLPS4_N"
          invert: true
    - out:
      name: "AUX_SSB_5V0_On"

  - P3V3_Unit:
    - in:
      and:
        - name: "P3V3_AUX_Enabled"
        - name: "P3V3_AUX_Fault"
          invert: true
        - name: "FM_SLPS4_N"
          invert: true
    - out:
      name: "AUX_SSB_3V3_On"

  - DDR_Power_Unit:
    - in:
      or:
        - name: "FM_SLPS3_N"
      and:
        - name: "FM_SLPS3_N"
          invert: true
        - name: "ACPI_STATE_S3"
    - out:
      name: "DDR_POWER"
    and_then_or: true

  # Must ramp before DDR_VDDQ, must retain 30 msec after DDR_VDDQ goes low
  - PVPP_ABC_Unit:
    - in:
      or:
        - name: "DDR_POWER"
        - name: "PVDDQ_ABC_DELAY"
        - name: "PVDDQ_ABC_Enabled"
    - out:
      name: "PVPP_ABC_On"

  # Ramp after DDR_VPP
  - PVDDQ_ABC_Unit:
    - in:
      and:
        - name: "DDR_POWER"
        - name: "PVPP_ABC_Enabled"
            input_stable_usec: 100
    - out:
      name: "PVDDQ_ABC_On"

  - PVDDQ_ABC_Delay_Unit:
    - in:
      and:
        - name: "PVDDQ_ABC_Enabled"
    - out:
      name: "PVDDQ_ABC_DELAY"
    delay_usec: 30000 # JEDEC recommendation

  - PWRGD_PCH_PWROK_Unit:
    - in:
      and:
        - name: "AUX_SSB_3V3_Enabled"
        - name: "AUX_SSB_3V3_Fault"
          invert: true
        - name: "AUX_SSB_5V0_Enabled"
        - name: "AUX_SSB_5V0_Fault"
          invert: true
        - name: "PVDDQ_ABC_Enabled"
        - name: "PVDDQ_ABC_Fault"
          invert: true
        - name: "PVPP_ABC_Enabled"
        - name: "PVPP_ABC_Fault"
          invert: true
    - out:
      name: "PWRGD_PCH_PWROK"

# List of PMBUS controlled voltage regulators
# Every voltage regulator emits a <name>_Enabled and <name>_Fault output signal
# Every voltage regulator emits a <name>_On input signal
# Volage regulators are configured on program start, and only read
# on fault conditions.
# A fault triggers an interrupt and starts the internal state machine.
pmbus_vregs:
  - P3V3_AUX:
    - vout: 3.3
    - vout_uv_fault_limit: 3.0 # DSW_PWRGD must be pulled low before voltage is less than 2900mV 
    - vout_ov_fault_limit: 3.4
    - vin_ov_fault_limit: 0.0
    - ton_max_fault_limit_msec: 0
    - fault_suppress_us: 100
  - P5V_AUX:
    - vout: 5.0
    - vout_uv_fault_limit: 4.8
    - vout_ov_fault_limit: 5.2
    - vin_ov_fault_limit: 0.0
    - ton_max_fault_limit_msec: 0
    - fault_suppress_us: 100
  - P1V8_PCH_AUX:
    - vout: 1.8
    - vout_uv_fault_limit: 1.7
    - vout_ov_fault_limit: 1.9
    - vin_ov_fault_limit: 0.0
    - ton_max_fault_limit_msec: 0
    - fault_suppress_us: 100
  - P1V05_PCH_AUX:
    - vout: 1.05
    - vout_uv_fault_limit: 1.0
    - vout_ov_fault_limit: 1.1
    - vin_ov_fault_limit: 0.0
    - ton_max_fault_limit_msec: 0
    - fault_suppress_us: 100
  - PVNN_PCH_AUX:
    - vout: 1.0
    - vout_uv_fault_limit: 0.8
    - vout_ov_fault_limit: 1.05
    - vin_ov_fault_limit: 0.0
    - ton_max_fault_limit_msec: 0
    - fault_suppress_us: 100
  - PVPP_ABC: # FIXME: Unknown communication protocol
    - vout: 2.5
  - PVDDQ_ABC: # FIXME: Unknown communication protocol
    - vout: 1.2



# List of switches
# Every switch emits a <name>_Enabled output signal and <name>_Fault output signal
# Every switch emits a <name>_On input signal
# A fault triggers an interrupt and starts the internal state machine.
switch:
  - AUX_SSB_3V3:
    name: "AUX_SSB"
    channel: 0
  - AUX_SSB_5V0:
    name: "AUX_SSB"
    channel: 1

# Special wake events
wake:
  - PWRBTN_N
    type: "PWRBTN"
    supported: false # As PWRBTN is not supported, S5->S0 will actually be S5->G3->S0

# List of platform supported PCH ACPI states.
# Only one state can be active at time. The state set here must not be the same as
# advertised by the PCH.
#
# 'wait_for_valid' is a list of signals that must be asserted after 'wait_timeout_msec' msec.
# If not valid then emit an error.
#
states:
  - ACPI_STATE_G3
    state: "G3"
    initial: true
  - ACPI_STATE_S5
    state: "S5"
    initial: false
    wait_for_valid:
      - "PWRGD_PCH_DPWROK"
      - "RST_PCH_RSMRST_R_N"
    wait_timeout_msec: 100
  - ACPI_STATE_S0
    state: "S0"
    initial: false
